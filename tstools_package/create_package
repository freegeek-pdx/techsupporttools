#!/bin/bash
# this file has the following standard layout
# CONFIGURATION
# help function
# INCLUDES
#FUNCTIONS
# process option arguments
# MAIN

# CONFIGURATION
path_to_src="/home/paulm/tstools/tstools_package/"
path_to_output="/home/paulm/"
version_file="${path_to_src}.version"
remote_host="tsbackup"

help(){
cat <<EOF 

usage: $0 [OPTION]...
Builds a tarball of the tstools package and updates the webpage. 
-h              Prints this message
-l [FILE]       Use logfile FILE
-n [VERSION]    New version number. Otherwise auto increments.
-m [MESSAGE]    A description of the changes for this version. 
-t              Ony build tarball.
-d              Only update documentation.
-D              Dry run. Run any tests but do not update anything.
-r [EMAIL]      Specify optional adress to send email to. 
                It is not necessary to specify an address. 
                There is one set by default in the script.

-f [EMAIL]      Set the from email adress. It is not necessary to 
                specify an address. There is one set by default in
                the script.

This script builds a tarball of a new version of the TStools package 
and updates the documentation. It will first run any tests and will complete 
only if they are sucessful. 

If you do not supply a version number it will auto-increment the last part
of the old version (e.g. 0.1.9 to 0.1.10).

You will be prompted for a description of the changes if you do not supply one.


Unless the -D -d or -t options are set it will automatically create a new ticket  with details of the new release and send an email out to support-staff (and any email set with the -r option.

EOF

# if $1 exists and is a number 0..255 return that otherwise return 0
if [[ -n $1 && $(echo {0..255}) =~ $1 ]]; then
        exit $1
else
    exit 0
fi
}
# INCLUDES
./ts_functions.sh 

#FUNCTIONS



# process option arguments
while getopts "hl:n:m:r:f:tdD" option; do        # w: place variable following w in $OPTARG
    case "$option" in
        h) help;;
        l) logfile="$OPTARG";;
        n) new_version="$OPTARG";;
        m) message=="$OPTARG";;
        r) recipient=$OPTARG;;
        f) sender=$OPTARG;;
        t) tar_only="true";;
        d) doc_only="true";;
        D) dryrun_only="true";;
        [?])  echo "bad option supplied" ;
            help;;
    esac
done

if [[ $recipient && ! $mail ]]; then
        echo "The -r option requires the use of -m"
elif [[ $sender && ! $mail ]]; then
        echo "The -f option requires the use of -m"
fi 
#MAIN

# Get old version number if not set
if [[ -e $version_file ]]; then
    old_version=$(cat $version_file)
else
    write_msg "Could not read $version_file!"
    write_msg "Please create this_file"
    exit 3
fi

# check we can write to the version file

if ! check_file_write $version_file; then
    write_msg "Could not write to $version_file!..exiting"
fi
if [[ ! $new_version ]]; then
    new_version=$(cp.increment_version $old_version)
fi
write_msg "New version: $new_version"


# run tests

for folder in unit-tests integration-tests; do
   folder/call-tests
   result=$?
   if [[ $result -eq 0 ]]; then
        write_msg "passed $folder"
   else
       write_msg "failed $folder" 
       exit 3
   fi
done

write_msg "passed all tests, proceeding to build package"
if [[ $dryrun_only ]]; then write_msg "(not really)"; fi

# create tar file 

tar_file=${path_to_output}tstools.${new_version}.tar.gz 
if [[ ! $doc_only ]]; then
    check_file_write $tar_file
    if [[ $? -ne 0 ]]; then
        write_msg "could not write to $tar_file"
        exit 73
    fi

    if [[ $dryrun_only ]]; then 
        write_msg "would create $tar_file"
        rm $tar_file
    elif ! tar -cvzf $tar_file  ${path_to_src}README ${path_to_src}ts* 
        write_msg "error creating $tar_file"
        rm $tar_file
        exit 73
    else
        write_msg "created $tar_file"
    fi

# copy file: scp $tarfile $remote_host:/var/www/
# if $USER/bin/rssh then rssh else ssh
# rssh tsbackup ln -s /var/www/tstools.${new_version}.tar.gz /var/www/tstools.tar.gz

    # copy file to remote host
    if [[ $dryrun_only ]]; then
        write_msg "would copy $tar_file to $remote_host"
    elif ! scp $tarfile $remote_host:/var/www/; then
        write_msg "Could not copy $tar_file to $remote_host"
        exit 69
    fi

    # worker around for the fact that I have a wrapper script for ssh 
    if [[ -e $USER/bin/rssh ]]; then
        ssh_command="rssh"
    else
        ssh_command="ssh"
    fi
    # create symlink from current version to tstools.tar.gz
    if [[ $dryrun_only ]]; then
        write_msg "would create sysmlink to tstools.tar.gz on $remote_host"
    elif ! $ssh_command $remote_host ln -s /var/www/tstools.${new_version}.tar.gz /var/www/tstools.tar.gz; then
        write_msg "create sysmlink to tstools.tar.gz on $remote_host"
        exit 69
    fi
fi
# edit ~/code/html/tsbackup/index.html (as var) 
# change line:
#The current version is <a href="/tstools.${old_version}.tar.gz">tstools.${old_version}.tar.gz</a>.<br /> 
#to 
#<a href="/tstools.${new_version}.tar.gz">tstools.${new_version}.tar.gz</a>.<br /> 

# split file on:
#             <strong>History</strong><br />
#            <dl class="flat">
# add:
#<dt class="flat"><a href="/tstools.${new_version}.tar.gz">tstools.${new_version}.tar.gz</a></dt>
#                <dd class="flat">$message.</dd>
#

# cd ~/code/html/tsbackup/
# git commit -m "update for $new_version" index.html
# git push tsbackup

# increment version if necessary then write to file
if [[ $dryrun_only ]]; then 
    echo "would update $version file to $new_version"
else
    echo "incrementing version"
    echo "$new_version" > $version_file
fi


